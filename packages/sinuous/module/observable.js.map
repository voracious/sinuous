{"version":3,"file":"observable.js","sources":["../observable/src/observable.js"],"sourcesContent":["const EMPTY_ARR = [];\nlet tracking;\nlet queue;\n\n/**\n * Returns true if there is an active observer.\n * @return {boolean}\n */\nexport function isListening() {\n  return !!tracking;\n}\n\n/**\n * Creates a root and executes the passed function that can contain computations.\n * The executed function receives an `unsubscribe` argument which can be called to\n * unsubscribe all inner computations.\n *\n * @param  {Function} fn\n * @return {*}\n */\nexport function root(fn) {\n  const prevTracking = tracking;\n  const rootUpdate = () => {};\n  tracking = rootUpdate;\n  resetUpdate(rootUpdate);\n  const result = fn(() => {\n    _unsubscribe(rootUpdate);\n    tracking = undefined;\n  });\n  tracking = prevTracking;\n  return result;\n}\n\n/**\n * Sample the current value of an observable but don't create a dependency on it.\n *\n * @example\n * computed(() => { if (foo()) bar(sample(bar) + 1); });\n *\n * @param  {Function} fn\n * @return {*}\n */\nexport function sample(fn) {\n  const prevTracking = tracking;\n  tracking = undefined;\n  const value = fn();\n  tracking = prevTracking;\n  return value;\n}\n\n/**\n * Creates a transaction in which an observable can be set multiple times\n * but only trigger a computation once.\n * @param  {Function} fn\n * @return {*}\n */\nexport function transaction(fn) {\n  let prevQueue = queue;\n  queue = [];\n  const result = fn();\n  let q = queue;\n  queue = prevQueue;\n  q.forEach(data => {\n    if (data._pending !== EMPTY_ARR) {\n      const pending = data._pending;\n      data._pending = EMPTY_ARR;\n      data(pending);\n    }\n  });\n  return result;\n}\n\n/**\n * Creates a new observable, returns a function which can be used to get\n * the observable's value by calling the function without any arguments\n * and set the value by passing one argument of any type.\n *\n * @param  {*} value - Initial value.\n * @return {Function}\n */\nfunction observable(value) {\n  function data(nextValue) {\n    if (arguments.length === 0) {\n      if (tracking && !data._observers.has(tracking)) {\n        data._observers.add(tracking);\n        tracking._observables.push(data);\n      }\n      return value;\n    }\n\n    if (queue) {\n      if (data._pending === EMPTY_ARR) {\n        queue.push(data);\n      }\n      data._pending = nextValue;\n      return nextValue;\n    }\n\n    value = nextValue;\n\n    // Clear `tracking` otherwise a computed triggered by a set\n    // in another computed is seen as a child of that other computed.\n    const clearedUpdate = tracking;\n    tracking = undefined;\n\n    // Update can alter data._observers, make a copy before running.\n    data._runObservers = new Set(data._observers);\n    data._runObservers.forEach(observer => (observer._fresh = false));\n    data._runObservers.forEach(observer => {\n      if (!observer._fresh) observer();\n    });\n\n    tracking = clearedUpdate;\n    return value;\n  }\n\n  // Tiny indicator that this is an observable function.\n  // Used in sinuous/h/src/property.js\n  data.$o = 1;\n  data._observers = new Set();\n  // The 'not set' value must be unique, so `nullish` can be set in a transaction.\n  data._pending = EMPTY_ARR;\n\n  return data;\n}\n\n/**\n * @namespace\n * @borrows observable as o\n */\nexport { observable, observable as o };\n\n/**\n * Creates a new computation which runs when defined and automatically re-runs\n * when any of the used observable's values are set.\n *\n * @param {Function} observer\n * @param {*} value - Seed value.\n * @return {Function} Computation which can be used in other computations.\n */\nfunction computed(observer, value) {\n  observer._update = update;\n\n  // if (tracking == null) {\n  //   console.warn(\"computations created without a root or parent will never be disposed\");\n  // }\n\n  resetUpdate(update);\n  update();\n\n  function update() {\n    const prevTracking = tracking;\n    if (tracking) {\n      tracking._children.push(update);\n    }\n\n    _unsubscribe(update);\n    update._fresh = true;\n    tracking = update;\n    value = observer(value);\n\n    tracking = prevTracking;\n    return value;\n  }\n\n  // Tiny indicator that this is an observable function.\n  // Used in sinuous/h/src/property.js\n  data.$o = 1;\n\n  function data() {\n    if (update._fresh) {\n      if (tracking) {\n        // If being read from inside another computed, pass observables to it\n        update._observables.forEach(o => o());\n      }\n    } else {\n      value = update();\n    }\n    return value;\n  }\n\n  return data;\n}\n\n/**\n * @namespace\n * @borrows computed as S\n */\nexport { computed, computed as S };\n\n/**\n * Run the given function just before the enclosing computation updates\n * or is disposed.\n * @param  {Function} fn\n * @return {Function}\n */\nexport function cleanup(fn) {\n  if (tracking) {\n    tracking._cleanups.push(fn);\n  }\n  return fn;\n}\n\n/**\n * Subscribe to updates of an observable.\n * @param  {Function} observer\n * @return {Function}\n */\nexport function subscribe(observer) {\n  computed(observer);\n  return () => _unsubscribe(observer._update);\n}\n\n/**\n * Statically declare a computation's dependencies.\n *\n * @param  {Function|Array}   obs\n * @param  {Function} fn - Callback function.\n * @param  {*} [seed] - Seed value.\n * @param  {boolean} [onchanges] - If true the initial run is skipped.\n * @return {Function} Computation which can be used in other computations.\n */\nexport function on(obs, fn, seed, onchanges) {\n  obs = [].concat(obs);\n  return computed((value) => {\n    obs.forEach((o) => o());\n\n    let result = value;\n    if (!onchanges) {\n      result = sample(() => fn(value));\n    }\n\n    onchanges = false;\n    return result;\n  }, seed);\n}\n\n/**\n * Unsubscribe from an observer.\n * @param  {Function} observer\n */\nexport function unsubscribe(observer) {\n  _unsubscribe(observer._update);\n}\n\nfunction _unsubscribe(update) {\n  update._children.forEach(_unsubscribe);\n  update._observables.forEach(o => {\n    o._observers.delete(update);\n    if (o._runObservers) {\n      o._runObservers.delete(update);\n    }\n  });\n  update._cleanups.forEach(c => c());\n  resetUpdate(update);\n}\n\nfunction resetUpdate(update) {\n  // Keep track of which observables trigger updates. Needed for unsubscribe.\n  update._observables = [];\n  update._children = [];\n  update._cleanups = [];\n}\n"],"names":["tracking","queue","isListening","root","fn","rootUpdate","resetUpdate","_unsubscribe","undefined","prevTracking","result","sample","value","transaction","prevQueue","q","forEach","data","_pending","EMPTY_ARR","pending","observable","nextValue","arguments","length","_observers","has","add","_observables","push","_runObservers","Set","observer","_fresh","clearedUpdate","$o","computed","update","_children","o","_update","cleanup","_cleanups","subscribe","on","obs","seed","onchanges","concat","unsubscribe","delete","c"],"mappings":"AAAA,MAAkB,GAClB,IAAIA,EACAC,EAMG,SAASC,IACd,QAASF,EAWJ,SAASG,EAAKC,GACnB,MAAqBJ,EACfK,EAAa,OACnBL,EAAWK,EACXC,EAAYD,GACZ,MAAeD,GAAG,KAChBG,EAAaF,GACbL,OAAWQ,KAGb,OADAR,EAAWS,EACJC,EAYF,SAASC,EAAOP,GACrB,MAAqBJ,EACrBA,OAAWQ,EACX,MAAcJ,IAEd,OADAJ,EAAWS,EACJG,EASF,SAASC,EAAYT,GAC1B,IAAIU,EAAYb,EAChBA,EAAQ,GACR,MAAeG,IACf,IAAIW,EAAId,EASR,OARAA,EAAQa,EACRC,EAAEC,SAAQC,IACR,GAAIA,EAAKC,IAAaC,EAAW,CAC/B,MAAgBF,EAAKC,EACrBD,EAAKC,EAAWC,EAChBF,EAAKG,OAGFV,EAWT,SAASW,EAAWT,GAClB,SAASK,EAAKK,GACZ,GAAyB,IAArBC,UAAUC,OAKZ,OAJIxB,IAAaiB,EAAKQ,IAAWC,IAAI1B,KACnCiB,EAAKQ,IAAWE,IAAI3B,GACpBA,EAAS4B,EAAaC,KAAKZ,IAEtBL,EAGT,GAAIX,EAKF,OAJIgB,EAAKC,IAAaC,GACpBlB,EAAM4B,KAAKZ,GAEbA,EAAKC,EAAWI,EACTA,EAGTV,EAAQU,EAIR,MAAsBtB,EAWtB,OAVAA,OAAWQ,EAGXS,EAAKa,EAAgB,IAAIC,IAAId,EAAKQ,KAClCR,EAAKa,EAAcd,SAAQgB,GAAaA,EAASC,GAAS,IAC1DhB,EAAKa,EAAcd,SAAQgB,IACpBA,EAASC,GAAQD,OAGxBhC,EAAWkC,EACJtB,EAUT,OALAK,EAAKkB,GAAK,EACVlB,EAAKQ,IAAa,IAAIM,IAEtBd,EAAKC,EAAWC,EAETF,EAiBT,SAASmB,EAASJ,EAAUpB,GAU1B,SAASyB,IACP,MAAqBrC,EAWrB,OAVIA,GACFA,EAASsC,IAAUT,KAAKQ,GAG1B9B,EAAa8B,GACbA,EAAOJ,GAAS,EAChBjC,EAAWqC,EACXzB,EAAQoB,EAASpB,GAEjBZ,EAAWS,EACJG,EAOT,SAASK,IASP,OARIoB,EAAOJ,EACLjC,GAEFqC,EAAOT,EAAaZ,SAAQuB,GAAKA,MAGnC3B,EAAQyB,IAEHzB,EAGT,OAxCAoB,EAASQ,EAAUH,EAMnB/B,EAAY+B,GACZA,IAmBApB,EAAKkB,GAAK,EAcHlB,EAeF,SAASwB,EAAQrC,GAItB,OAHIJ,GACFA,EAAS0C,EAAUb,KAAKzB,GAEnBA,EAQF,SAASuC,EAAUX,GAExB,OADAI,EAASJ,GACF,IAAMzB,EAAayB,EAASQ,GAY9B,SAASI,EAAGC,EAAKzC,EAAI0C,EAAMC,GAEhC,OADAF,EAAM,GAAGG,OAAOH,GACTT,GAAUxB,IACfiC,EAAI7B,SAASuB,GAAMA,MAEnB,IAAI7B,EAASE,EAMb,OALKmC,IACHrC,EAASC,GAAO,IAAMP,EAAGQ,MAG3BmC,GAAY,EACLrC,IACNoC,GAOE,SAASG,EAAYjB,GAC1BzB,EAAayB,EAASQ,GAGxB,SAASjC,EAAa8B,GACpBA,EAAOC,IAAUtB,QAAQT,GACzB8B,EAAOT,EAAaZ,SAAQuB,IAC1BA,EAAEd,IAAWyB,OAAOb,GAChBE,EAAET,GACJS,EAAET,EAAcoB,OAAOb,MAG3BA,EAAOK,EAAU1B,SAAQmC,GAAKA,MAC9B7C,EAAY+B,GAGd,SAAS/B,EAAY+B,GAEnBA,EAAOT,EAAe,GACtBS,EAAOC,IAAY,GACnBD,EAAOK,EAAY"}