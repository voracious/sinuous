{"version":3,"file":"babel-plugin-htm.js","sources":["../babel-plugin-htm/src/index.js","../htm/src/build.js"],"sourcesContent":["import { build, treeify } from '../../htm/src/build.js';\n\n/**\n * @param {{ types: import('@babel/types') }} babel\n * @param {object} options\n * @param {string | false} [options.pragma=h]  JSX/hyperscript pragma.\n * @param {string} [options.tag=html]  The tagged template \"tag\" function name to process.\n * @param {string | boolean | object} [options.import=false]  Import the tag automatically\n * @param {boolean} [options.monomorphic=false]  Output monomorphic inline objects instead of using String literals.\n * @param {boolean} [options.useBuiltIns=false]  Use the native Object.assign instead of trying to polyfill it.\n * @param {boolean} [options.useNativeSpread=false]  Use the native { ...a, ...b } syntax for prop spreads.\n * @param {boolean} [options.variableArity=true] If `false`, always passes exactly 3 arguments to the pragma function.\n * @param {boolean} [options.wrapExpression=''] If set wraps the generated expression with a function passing the same arguments the tagged template would receive.\n */\nexport default function htmBabelPlugin({ types: t }, options = {}) {\n  const pragmaString = options.pragma === false ? false : options.pragma || 'h';\n  const pragma = pragmaString === false ? false : dottedIdentifier(pragmaString);\n  const useBuiltIns = options.useBuiltIns;\n  const useNativeSpread = options.useNativeSpread;\n  const inlineVNodes = options.monomorphic || pragma === false;\n  const importDeclaration = pragmaImport(options.import || false);\n  const wrapExpression = options.wrapExpression;\n  let fields;\n\n  function pragmaImport(imp) {\n    if (pragmaString === false || imp === false) {\n      return null;\n    }\n    const pragmaRoot = t.identifier(pragmaString.split('.')[0]);\n    const { module, export: export_ } = typeof imp !== 'string' ? imp : {\n      module: imp,\n      export: null\n    };\n\n    let specifier;\n    if (export_ === '*') {\n      specifier = t.importNamespaceSpecifier(pragmaRoot);\n    }\n    else if (export_ === 'default') {\n      specifier = t.importDefaultSpecifier(pragmaRoot);\n    }\n    else {\n      specifier = t.importSpecifier(pragmaRoot, export_ ? t.identifier(export_) : pragmaRoot);\n    }\n    return t.importDeclaration([specifier], t.stringLiteral(module));\n  }\n\n  function dottedIdentifier(keypath) {\n    const path = keypath.split('.');\n    let out;\n    for (let i = 0; i < path.length; i++) {\n      const ident = propertyName(path[i]);\n      out = i === 0 ? ident : t.memberExpression(out, ident);\n    }\n    return out;\n  }\n\n  function patternStringToRegExp(str) {\n    const parts = str.split('/').slice(1);\n    const end = parts.pop() || '';\n    return new RegExp(parts.join('/'), end);\n  }\n\n  function propertyName(key) {\n    if (t.isValidIdentifier(key)) {\n      return t.identifier(key);\n    }\n    return t.stringLiteral(key);\n  }\n\n  function objectProperties(obj) {\n    return Object.keys(obj).map(key => {\n      const values = obj[key].map(valueOrNode =>\n        t.isNode(valueOrNode) ? maybeField(valueOrNode) : t.valueToNode(valueOrNode)\n      );\n\n      let node = values[0];\n      if (values.length > 1) {\n        if (!t.isStringLiteral(node)) {\n          node = t.binaryExpression('+', t.stringLiteral(''), concatFunctionNode(node));\n        }\n        values.slice(1).forEach(value => {\n          node = t.binaryExpression('+', node, concatFunctionNode(value));\n        });\n        if (values.some(isFunctionLike)) {\n          node = t.functionExpression(null, [], t.blockStatement([\n            t.returnStatement(node)\n          ]));\n        }\n      }\n\n      return t.objectProperty(propertyName(key), node);\n    });\n  }\n\n  function stringValue(str) {\n    if (options.monomorphic) {\n      return t.objectExpression([\n        t.objectProperty(propertyName('type'), t.numericLiteral(3)),\n        t.objectProperty(propertyName('tag'), t.nullLiteral()),\n        t.objectProperty(propertyName('props'), t.nullLiteral()),\n        t.objectProperty(propertyName('children'), t.nullLiteral()),\n        t.objectProperty(propertyName('text'), t.stringLiteral(str))\n      ]);\n    }\n    return t.stringLiteral(str);\n  }\n\n  function createVNode(tag, props, children) {\n    // Never pass children=[[]].\n    if (\n      children.elements.length === 1 &&\n      t.isArrayExpression(children.elements[0]) &&\n      children.elements[0].elements.length === 0\n    ) {\n      children = children.elements[0];\n    }\n\n    if (inlineVNodes) {\n      return t.objectExpression([\n        options.monomorphic && t.objectProperty(propertyName('type'), t.numericLiteral(1)),\n        t.objectProperty(propertyName('tag'), tag),\n        t.objectProperty(propertyName('props'), props),\n        t.objectProperty(propertyName('children'), children),\n        options.monomorphic && t.objectProperty(propertyName('text'), t.nullLiteral())\n      ].filter(Boolean));\n    }\n\n    // Passing `{variableArity:false}` always produces `h(tag, props, children)` - where `children` is always an Array.\n    // Otherwise, the default is `h(tag, props, ...children)`.\n    if (options.variableArity !== false) {\n      children = children.elements;\n    }\n\n    return t.callExpression(pragma, [tag, props].concat(children));\n  }\n\n  function spreadNode(args, state) {\n    if (!args || args.length === 0) {\n      return t.nullLiteral();\n    }\n    if (args.length > 0 && t.isNode(args[0])) {\n      args.unshift({});\n    }\n\n    // 'Object.assign(x)', can be collapsed to 'x'.\n    if (args.length === 1) {\n      return propsNode(args[0]);\n    }\n    // 'Object.assign({}, x)', can be collapsed to 'x'.\n    if (args.length === 2 && !t.isNode(args[0]) && Object.keys(args[0]).length === 0) {\n      return propsNode(args[1]);\n    }\n\n    if (useNativeSpread) {\n      const properties = [];\n      args.forEach(arg => {\n        if (t.isNode(arg)) {\n          properties.push(t.spreadElement(arg));\n        }\n        else {\n          properties.push(...objectProperties(arg));\n        }\n      });\n      return t.objectExpression(properties);\n    }\n\n    const helper = useBuiltIns ? dottedIdentifier('Object.assign') : state.addHelper('extends');\n    return t.callExpression(helper, args.map(propsNode));\n  }\n\n  function propsNode(props) {\n    return t.isNode(props) ? maybeField(props) : t.objectExpression(objectProperties(props));\n  }\n\n  function transform(node, state) {\n    node = maybeField(node);\n\n    if (t.isNode(node)) return node;\n    if (typeof node === 'string') return stringValue(node);\n    if (node === undefined) return t.identifier('undefined');\n\n    const { tag, props, children } = node;\n    const isComponent = typeof tag !== 'string';\n    const newTag = isComponent ? tag : t.stringLiteral(tag);\n    const newProps = spreadNode(props, state);\n    const newChildren = t.arrayExpression((children || [])\n      .map(child => transform(child, state))\n      .map(child => isComponent ? t.arrowFunctionExpression([], child) : child));\n    return createVNode(newTag, newProps, newChildren);\n  }\n\n  function maybeField(node) {\n    if (fields.has(node)) {\n      return fields.get(node);\n    }\n    return node;\n  }\n\n  function isFunctionLike(node) {\n    return (\n      t.isIdentifier(node) ||\n      t.isFunctionExpression(node) ||\n      t.isArrowFunctionExpression(node)\n    );\n  }\n\n  function concatFunctionNode(node) {\n    if (isFunctionLike(node)) {\n      const typeofNode = t.unaryExpression('typeof', node);\n      const isNodeFunction = t.binaryExpression('===', typeofNode, t.stringLiteral('function'));\n      return t.conditionalExpression(isNodeFunction, t.callExpression(t.memberExpression(node, t.identifier('call')), [t.thisExpression()]), node);\n    }\n    return node;\n  }\n\n  // The tagged template tag function name we're looking for.\n  // This is static because it's generally assigned via htm.bind(h),\n  // which could be imported from elsewhere, making tracking impossible.\n  const htmlName = options.tag || 'html';\n  return {\n    name: 'htm',\n    visitor: {\n      Program: {\n        exit(path, state) {\n          if (state.get('hasHtm') && importDeclaration) {\n            path.unshiftContainer('body', importDeclaration);\n          }\n        },\n      },\n      TaggedTemplateExpression(path, state) {\n        fields = new Map();\n\n        const tag = path.node.tag.name;\n        if (htmlName[0] === '/' ? patternStringToRegExp(htmlName).test(tag) : tag === htmlName) {\n          const statics = path.node.quasi.quasis.map(e => e.value.raw);\n          const exprs = path.node.quasi.expressions;\n\n          let tree = treeify(build(statics), exprs);\n\n          // Turn array expression in Array so it can be converted below\n          // to a pragma call expression for fragments.\n          if (t.isArrayExpression(tree)) {\n            tree = tree.elements;\n          }\n\n          if (wrapExpression) {\n            exprs.forEach(expr => {\n              fields.set(expr, path.scope.generateUidIdentifier(\"field\"));\n            });\n          }\n\n          let node = Array.isArray(tree)\n            ? t.callExpression(pragma, [\n              t.arrayExpression(tree.map(root => transform(root, state)))\n            ])\n            : t.isNode(tree) || typeof tree === 'string'\n              ? t.callExpression(pragma, [\n                t.arrayExpression([transform(tree, state)])\n              ])\n              : transform(tree, state);\n\n          if (wrapExpression) {\n            let taggedArgs = Array.from(fields.values());\n            taggedArgs.unshift(path.scope.generateUidIdentifier(\"statics\"));\n\n            node = t.callExpression(dottedIdentifier(`${wrapExpression}.apply`), [\n              t.arrowFunctionExpression(taggedArgs, node),\n              t.arrayExpression([\n                t.arrayExpression(statics.map(str => t.stringLiteral(str))),\n                ...exprs\n              ])\n            ]);\n          }\n          path.replaceWith(node);\n          state.set('hasHtm', true);\n        }\n      }\n    }\n  };\n}\n","import { MINI } from './constants.js';\n\nconst MODE_SLASH = 0;\nconst MODE_TEXT = 1;\nconst MODE_WHITESPACE = 2;\nconst MODE_TAGNAME = 3;\nconst MODE_COMMENT = 4;\nconst MODE_PROP_SET = 5;\nconst MODE_PROP_APPEND = 6;\n\nconst TAG_SET = 1;\nconst CHILD_APPEND = 0;\nconst CHILD_RECURSE = 2;\nconst PROPS_ASSIGN = 3;\nconst PROP_SET = MODE_PROP_SET;\nconst PROP_APPEND = MODE_PROP_APPEND;\n\n// Turn a result of a build(...) call into a tree that is more\n// convenient to analyze and transform (e.g. Babel plugins).\n// For example:\n//  treeify(\n//    build'<div href=\"1${a}\" ...${b}><${x} /></div>`,\n//    [X, Y, Z]\n//  )\n// returns:\n//  {\n//    tag: 'div',\n//    props: [ { href: [\"1\", X] },  Y ],\n//    children: [ { tag: Z, props: [], children: [] } ]\n//  }\nexport const treeify = (built, fields) => {\n  const _treeify = built => {\n    let tag = '';\n    let currentProps = null;\n    const props = [];\n    const children = [];\n\n    for (let i = 1; i < built.length; i++) {\n      const field = built[i++];\n      const value = typeof field === 'number' ? fields[field - 1] : field;\n\n      if (built[i] === TAG_SET) {\n        tag = value;\n      }\n      else if (built[i] === PROPS_ASSIGN) {\n        props.push(value);\n        currentProps = null;\n      }\n      else if (built[i] === PROP_SET) {\n        if (!currentProps) {\n          currentProps = Object.create(null);\n          props.push(currentProps);\n        }\n        currentProps[built[++i]] = [value];\n      }\n      else if (built[i] === PROP_APPEND) {\n        currentProps[built[++i]].push(value);\n      }\n      else if (built[i] === CHILD_RECURSE) {\n        children.push(_treeify(value));\n      }\n      else if (built[i] === CHILD_APPEND) {\n        children.push(value);\n      }\n    }\n\n    return { tag, props, children };\n  };\n  const { children } = _treeify(built);\n  return children.length > 1 ? children : children[0];\n};\n\n\nexport const evaluate = (h, built, fields, args) => {\n  let propBody = {};\n  for (let i = 1; i < built.length; i++) {\n    const field = built[i];\n    const value = typeof field === 'number' ? fields[field] : field;\n    const type = built[++i];\n\n    if (type === TAG_SET) {\n      args[0] = value;\n    }\n    else if (type === PROPS_ASSIGN) {\n      args[1] = Object.assign(args[1] || {}, value);\n    }\n    else if (type === PROP_SET) {\n      (args[1] = args[1] || {})[built[++i]] = value;\n    }\n    else if (type === PROP_APPEND) {\n      let key = built[++i];\n      let prev = (args[1] = args[1] || {})[key];\n      let parts = propBody[key];\n\n      if (!parts && (typeof value === 'function' || typeof prev === 'function')) {\n        parts = (prev && [prev]) || [];\n\n        args[1][key] = function() {\n          let prop = '';\n          for (var j = 0; j < parts.length; j++) {\n            prop += typeof parts[j] === 'function' ? parts[j].call(this) : parts[j];\n          }\n          return prop;\n        };\n      }\n\n      if (parts) {\n        parts.push(value);\n      } else {\n        args[1][key] += (value + '');\n      }\n    }\n    else if (type) {\n      // code === CHILD_RECURSE\n      const result = () => h.apply(null, evaluate(h, value, fields, ['', null]));\n\n      // if it's a component we pass the children with closure so the\n      // component is executed before the children of that component.\n      args.push(typeof args[0] === 'function' ? result : result());\n    }\n    else {\n      // code === CHILD_APPEND\n      args.push(value);\n    }\n  }\n\n  return args;\n};\n\nexport const build = function(statics) {\n  const fields = arguments;\n  const h = this;\n\n  let mode = MODE_TEXT;\n  let buffer = '';\n  let quote = '';\n  let current = [0];\n  let char, propName;\n\n  const commit = field => {\n    if (mode === MODE_TEXT && (field || (buffer = buffer.replace(/^\\s*\\n\\s*|\\s*\\n\\s*$/g,'')))) {\n      if (MINI) {\n        current.push(field ? fields[field] : buffer);\n      }\n      else {\n        current.push(field || buffer, CHILD_APPEND);\n      }\n    }\n    else if (mode === MODE_TAGNAME && (field || buffer)) {\n      if (MINI) {\n        current[1] = field ? fields[field] : buffer;\n      }\n      else {\n        current.push(field || buffer, TAG_SET);\n      }\n      mode = MODE_WHITESPACE;\n    }\n    else if (mode === MODE_WHITESPACE && buffer === '...' && field) {\n      if (MINI) {\n        current[2] = Object.assign(current[2] || {}, fields[field]);\n      }\n      else {\n        current.push(field, PROPS_ASSIGN);\n      }\n    }\n    else if (mode === MODE_WHITESPACE && buffer && !field) {\n      if (MINI) {\n        (current[2] = current[2] || {})[buffer] = true;\n      }\n      else {\n        current.push(true, PROP_SET, buffer);\n      }\n    }\n    else if (mode >= MODE_PROP_SET) {\n      if (MINI) {\n        if (mode === MODE_PROP_SET) {\n          (current[2] = current[2] || {})[propName] = field ? buffer ? (buffer + fields[field]) : fields[field] : buffer;\n          mode = MODE_PROP_APPEND;\n        }\n        else if (field || buffer) {\n          current[2][propName] += field ? buffer + fields[field] : buffer;\n        }\n      }\n      else {\n        if (buffer || (!field && mode === MODE_PROP_SET)) {\n          current.push(buffer, mode, propName);\n          mode = MODE_PROP_APPEND;\n        }\n        if (field) {\n          current.push(field, mode, propName);\n          mode = MODE_PROP_APPEND;\n        }\n      }\n    }\n\n    buffer = '';\n  };\n\n  for (let i=0; i<statics.length; i++) {\n    if (i) {\n      if (mode === MODE_TEXT) {\n        commit();\n      }\n      commit(i);\n    }\n\n    for (let j=0; j<statics[i].length;j++) {\n      char = statics[i][j];\n\n      if (mode === MODE_TEXT) {\n        if (char === '<') {\n          // commit buffer\n          commit();\n          if (MINI) {\n            current = [current, '', null];\n          }\n          else {\n            current = [current];\n          }\n          mode = MODE_TAGNAME;\n        }\n        else {\n          buffer += char;\n        }\n      }\n      else if (mode === MODE_COMMENT) {\n        // Ignore everything until the last three characters are '-', '-' and '>'\n        if (buffer === '--' && char === '>') {\n          mode = MODE_TEXT;\n          buffer = '';\n        }\n        else {\n          buffer = char + buffer[0];\n        }\n      }\n      else if (quote) {\n        if (char === quote) {\n          quote = '';\n        }\n        else {\n          buffer += char;\n        }\n      }\n      else if (char === '\"' || char === \"'\") {\n        quote = char;\n      }\n      else if (char === '>') {\n        commit();\n        mode = MODE_TEXT;\n      }\n      else if (!mode) {\n        // Ignore everything until the tag ends\n      }\n      else if (char === '=') {\n        mode = MODE_PROP_SET;\n        propName = buffer;\n        buffer = '';\n      }\n      else if (char === '/' && (mode < MODE_PROP_SET || statics[i][j+1] === '>')) {\n        commit();\n        if (mode === MODE_TAGNAME) {\n          current = current[0];\n        }\n        mode = current;\n        if (MINI) {\n          (current = current[0]).push(h.apply(null, mode.slice(1)));\n        }\n        else {\n          (current = current[0]).push(mode, CHILD_RECURSE);\n        }\n        mode = MODE_SLASH;\n      }\n      else if (char === ' ' || char === '\\t' || char === '\\n' || char === '\\r') {\n        // <a disabled>\n        commit();\n        mode = MODE_WHITESPACE;\n      }\n      else {\n        buffer += char;\n      }\n\n      if (mode === MODE_TAGNAME && buffer === '!--') {\n        mode = MODE_COMMENT;\n        current = current[0];\n      }\n    }\n  }\n  commit();\n\n  if (MINI) {\n    return current.length > 2 ? current.slice(1) : current[1];\n  }\n  return current;\n};\n"],"names":["htmBabelPlugin","types","t","options","pragma","pragmaString","dottedIdentifier","useBuiltIns","useNativeSpread","inlineVNodes","monomorphic","importDeclaration","imp","identifier","split","module","export","export_","specifier","importNamespaceSpecifier","pragmaRoot","importDefaultSpecifier","importSpecifier","stringLiteral","pragmaImport","import","wrapExpression","fields","keypath","out","i","path","length","propertyName","ident","memberExpression","key","isValidIdentifier","objectProperties","obj","Object","keys","map","valueOrNode","isNode","maybeField","valueToNode","node","values","isStringLiteral","binaryExpression","concatFunctionNode","slice","forEach","value","some","isFunctionLike","functionExpression","blockStatement","returnStatement","objectProperty","propsNode","props","objectExpression","transform","state","str","numericLiteral","nullLiteral","undefined","tag","children","isComponent","newTag","newProps","args","unshift","arg","properties","push","spreadElement","addHelper","callExpression","helper","spreadNode","elements","isArrayExpression","filter","Boolean","variableArity","concat","createVNode","arrayExpression","child","arrowFunctionExpression","has","get","isIdentifier","isFunctionExpression","isArrowFunctionExpression","unaryExpression","isNodeFunction","typeofNode","conditionalExpression","thisExpression","name","visitor","Program","exit","unshiftContainer","TaggedTemplateExpression","Map","htmlName","end","parts","pop","RegExp","join","patternStringToRegExp","test","quasi","quasis","e","raw","exprs","expressions","tree","built","currentProps","field","create","_treeify","treeify","statics","char","propName","mode","buffer","quote","current","replace","commit","j","build","expr","set","scope","generateUidIdentifier","Array","isArray","root","taggedArgs","from","replaceWith"],"mappings":"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"}