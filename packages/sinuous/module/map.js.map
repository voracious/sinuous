{"version":3,"file":"map.js","sources":["../map/src/constants.js","../map/src/utils.js","../map/src/map.js"],"sourcesContent":["export const GROUPING = '__g';\nexport const FORWARD = 'nextSibling';\nexport const BACKWARD = 'previousSibling';\n","import { api } from 'sinuous';\nimport { GROUPING } from './constants.js';\n\nlet groupCounter = 0;\n\nexport function add(parent, value, endMark) {\n  let mark;\n\n  if (typeof value === 'string') {\n    value = document.createTextNode(value);\n  } else if (!(value instanceof Node)) {\n    // Passing an empty array creates a DocumentFragment.\n    value = api.h([], value);\n  }\n\n  if (\n    value.nodeType === 11 &&\n    (mark = value.firstChild) &&\n    mark !== value.lastChild\n  ) {\n    mark[GROUPING] = value.lastChild[GROUPING] = ++groupCounter;\n  }\n\n  // If endMark is `null`, value will be added to the end of the list.\n  parent.insertBefore(value, endMark);\n\n  // Explicit undefined to store if frag.firstChild is null.\n  return mark || value;\n}\n\nexport function step(node, direction, inner) {\n  const key = node[GROUPING];\n  if (key) {\n    node = node[direction];\n    while (node && node[GROUPING] !== key) {\n      node = node[direction];\n    }\n  }\n  return inner ? node : node[direction];\n}\n\nexport function removeNodes(parent, node, end) {\n  let tmp;\n  while (node !== end) {\n    tmp = node.nextSibling;\n    parent.removeChild(node);\n    node = tmp;\n  }\n}\n\nexport function insertNodes(parent, node, end, target) {\n  let tmp;\n  while (node !== end) {\n    tmp = node.nextSibling;\n    parent.insertBefore(node, target);\n    node = tmp;\n  }\n}\n\n// Picked from\n// https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L368\n\n// return an array of the indices of ns that comprise the longest increasing subsequence within ns\nexport function longestPositiveIncreasingSubsequence(ns, newStart) {\n  let seq = [];\n  let is = [];\n  let l = -1;\n  let pre = new Array(ns.length);\n\n  for (var i = newStart, len = ns.length; i < len; i++) {\n    var n = ns[i];\n    if (n < 0) continue;\n    var j = findGreatestIndexLEQ(seq, n);\n    if (j !== -1) pre[i] = is[j];\n    if (j === l) {\n      l++;\n      seq[l] = n;\n      is[l] = i;\n    } else if (n < seq[j + 1]) {\n      seq[j + 1] = n;\n      is[j + 1] = i;\n    }\n  }\n\n  for (i = is[l]; l >= 0; i = pre[i], l--) {\n    seq[l] = i;\n  }\n\n  return seq;\n}\n\nexport function findGreatestIndexLEQ(seq, n) {\n  // invariant: lo is guaranteed to be index of a value <= n, hi to be >\n  // therefore, they actually start out of range: (-1, last + 1)\n  let lo = -1;\n  let hi = seq.length;\n\n  // fast path for simple increasing sequences\n  if (hi > 0 && seq[hi - 1] <= n) return hi - 1;\n\n  while (hi - lo > 1) {\n    var mid = ((lo + hi) / 2) | 0;\n    if (seq[mid] > n) {\n      hi = mid;\n    } else {\n      lo = mid;\n    }\n  }\n\n  return lo;\n}\n","/* Adapted from Stage0 - The MIT License - Pavel Martynov */\n/* Adapted from DOM Expressions - The MIT License - Ryan Carniato */\nimport { api } from 'sinuous';\nimport { FORWARD, BACKWARD } from './constants.js';\nimport {\n  longestPositiveIncreasingSubsequence,\n  insertNodes,\n  removeNodes,\n  step,\n  add\n} from './utils.js';\n\n/**\n * Map over a list of items that create DOM nodes.\n *\n * @param  {Function} items - Function or observable that creates a list.\n * @param  {Function} expr\n * @param {boolean} [cleaning]\n * @return {DocumentFragment}\n */\nexport function map(items, expr, cleaning) {\n  const { subscribe, root, sample, cleanup } = api;\n\n  // Disable cleaning for templates by default.\n  if (cleaning == null) cleaning = !expr.$t;\n\n  let parent = document.createDocumentFragment();\n  const beforeNode = add(parent, '');\n  const afterNode = add(parent, '');\n  const disposers = new Map();\n\n  const unsubscribe = subscribe(a => {\n    const b = items();\n    return sample(() =>\n      reconcile(\n        a || [],\n        b || [],\n        beforeNode,\n        afterNode,\n        createFn,\n        cleaning && disposeAll,\n        cleaning && dispose\n      )\n    );\n  });\n\n  cleanup(unsubscribe);\n  cleanup(disposeAll);\n\n  function disposeAll() {\n    disposers.forEach(d => d());\n    disposers.clear();\n  }\n\n  function dispose(node) {\n    let disposer = disposers.get(node);\n    disposer && disposer();\n    disposers.delete(node);\n  }\n\n  function createFn(parent, item, i, data, afterNode) {\n    // The root call makes it possible the child's computations outlive\n    // their parents' update cycle.\n    return cleaning\n      ? root(disposeFn => {\n          const node = add(parent, expr(item, i, data), afterNode);\n          disposers.set(node, disposeFn);\n          return node;\n        })\n      : add(parent, expr(item, i, data), afterNode);\n  }\n\n  return parent;\n}\n\n// This is almost straightforward implementation of reconcillation algorithm\n// based on ivi documentation:\n// https://github.com/localvoid/ivi/blob/2c81ead934b9128e092cc2a5ef2d3cabc73cb5dd/packages/ivi/src/vdom/implementation.ts#L1366\n// With some fast paths from Surplus implementation:\n// https://github.com/adamhaile/surplus/blob/master/src/runtime/content.ts#L86\n// And working with data directly from Stage0:\n// https://github.com/Freak613/stage0/blob/master/reconcile.js\n// This implementation is tailored for fine grained change detection and adds support for fragments\nexport function reconcile(\n  a,\n  b,\n  beforeNode,\n  afterNode,\n  createFn,\n  onClear,\n  onRemove\n) {\n  // When parent was a DocumentFragment, then items got appended to the DOM.\n  const parent = afterNode.parentNode;\n\n  let length = b.length;\n  let i;\n\n  // Fast path for clear\n  if (length === 0) {\n    let startMark = beforeNode.previousSibling;\n    if (\n      (startMark && startMark.previousSibling)\n      || afterNode.nextSibling\n    ) {\n      removeNodes(parent, beforeNode.nextSibling, afterNode);\n    } else {\n      parent.textContent = '';\n      if (startMark) {\n        parent.appendChild(startMark);\n      }\n      parent.appendChild(beforeNode);\n      parent.appendChild(afterNode);\n    }\n\n    onClear && onClear();\n    return [];\n  }\n\n  // Fast path for create\n  if (a.length === 0) {\n    for (i = 0; i < length; i++) {\n      createFn(parent, b[i], i, b, afterNode);\n    }\n    return b.slice();\n  }\n\n  let aStart = 0;\n  let bStart = 0;\n  let aEnd = a.length - 1;\n  let bEnd = length - 1;\n  let tmp;\n  let aStartNode = beforeNode.nextSibling;\n  let aEndNode = afterNode.previousSibling;\n  let bAfterNode = afterNode;\n  let mark;\n\n  fixes: while (true) {\n    // Skip prefix\n    while (a[aStart] === b[bStart]) {\n      bStart++;\n      aStartNode = step(aStartNode, FORWARD);\n      if (aEnd < ++aStart || bEnd < bStart) break fixes;\n    }\n\n    // Skip suffix\n    while (a[aEnd] === b[bEnd]) {\n      bEnd--;\n      bAfterNode = step(aEndNode, BACKWARD, true);\n      aEndNode = bAfterNode.previousSibling;\n      if (--aEnd < aStart || bEnd < bStart) break fixes;\n    }\n\n    break;\n  }\n\n  // Fast path for shrink\n  if (bEnd < bStart) {\n    while (aStart <= aEnd--) {\n      tmp = step(aEndNode, BACKWARD, true);\n      mark = tmp.previousSibling;\n      removeNodes(parent, tmp, aEndNode.nextSibling);\n      onRemove && onRemove(tmp);\n      aEndNode = mark;\n    }\n    return b.slice();\n  }\n\n  // Fast path for add\n  if (aEnd < aStart) {\n    while (bStart <= bEnd) {\n      createFn(parent, b[bStart++], bStart, b, bAfterNode);\n    }\n    return b.slice();\n  }\n\n  // Positions for reusing nodes from current DOM state\n  const P = new Array(bEnd + 1 - bStart);\n  // Index to resolve position from current to new\n  const I = new Map();\n  for (i = bStart; i <= bEnd; i++) {\n    P[i] = -1;\n    I.set(b[i], i);\n  }\n\n  // Re-using `length` variable for reusing nodes count.\n  length = 0;\n  let toRemove = [];\n  for (i = aStart; i <= aEnd; i++) {\n    tmp = I.get(a[i]);\n    if (tmp) {\n      P[tmp] = i;\n      length++;\n    } else {\n      toRemove.push(i);\n    }\n  }\n\n  // Fast path for full replace\n  if (length === 0) {\n    return reconcile(\n      reconcile(a, [], beforeNode, afterNode, createFn, onClear),\n      b,\n      beforeNode,\n      afterNode,\n      createFn\n    );\n  }\n\n  // Collect nodes to work with them\n  const nodes = [];\n  tmp = aStartNode;\n  for (i = aStart; i <= aEnd; i++) {\n    nodes[i] = tmp;\n    tmp = step(tmp, FORWARD);\n  }\n\n  for (i = 0; i < toRemove.length; i++) {\n    let index = toRemove[i];\n    tmp = nodes[index];\n    removeNodes(parent, tmp, step(tmp, FORWARD));\n    onRemove && onRemove(tmp);\n  }\n\n  const longestSeq = longestPositiveIncreasingSubsequence(P, bStart);\n  // Re-use `length` for longest sequence length.\n  length = longestSeq.length - 1;\n\n  for (i = bEnd; i >= bStart; i--) {\n    if (longestSeq[length] === i) {\n      bAfterNode = nodes[P[longestSeq[length]]];\n      length--;\n    } else {\n      if (P[i] === -1) {\n        tmp = createFn(parent, b[i], i, b, bAfterNode);\n      } else {\n        tmp = nodes[P[i]];\n        insertNodes(parent, tmp, step(tmp, FORWARD), bAfterNode);\n      }\n      bAfterNode = tmp;\n    }\n  }\n\n  return b.slice();\n}\n"],"names":["groupCounter","add","parent","value","endMark","mark","document","createTextNode","Node","api","h","nodeType","firstChild","lastChild","insertBefore","step","node","direction","inner","key","removeNodes","end","tmp","nextSibling","removeChild","insertNodes","target","findGreatestIndexLEQ","seq","n","lo","hi","length","mid","map","items","expr","cleaning","subscribe","root","sample","cleanup","$t","createDocumentFragment","afterNode","disposers","Map","disposeAll","forEach","d","clear","dispose","disposer","get","delete","createFn","item","i","data","disposeFn","set","a","reconcile","b","beforeNode","onClear","onRemove","parentNode","startMark","previousSibling","textContent","appendChild","slice","aStart","bStart","aEnd","bEnd","aStartNode","aEndNode","bAfterNode","fixes","FORWARD","P","Array","I","toRemove","push","nodes","ns","newStart","is","l","pre","len","j","longestPositiveIncreasingSubsequence","longestSeq"],"mappings":"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"}